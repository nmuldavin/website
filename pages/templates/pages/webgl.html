{% extends 'pages/base.html' %}

{% load staticfiles %}

{% block stylesheetslast %}
    <link src="{% static 'pages/css/canvas.css' %}" rel="stylesheet">
    <script src="{% static 'pages/js/webgl-utils.js' %}"></script>
  <script>


    window.onload = main;

    function main() {
      // Get A WebGL context
      var canvas = document.getElementById("canvas");
      canvas.width  = 0.9*window.innerWidth;
      canvas.height = 0.9*window.innerHeight;
      var gl = getWebGLContext(canvas, {}, {noTitle: true});
      if (!gl) {
        return;
      }

      // setup GLSL program
      var program = createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader"]);
      gl.useProgram(program);

      // look up where the vertex data needs to go.
      var positionLocation = gl.getAttribLocation(program, "a_position");

      // lookup uniforms
      var colorLocation = gl.getUniformLocation(program, "u_color");

      // Create a buffer.
      var buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      drawScene();

      var fps = 0.5;
      function drawScene() {
        setTimeout(function() {
          requestAnimationFrame(drawScene);
          // draw 50 random rectangles in random colors
          for (var ii = 0; ii < 50; ++ii) {
            // Setup a random rectangle
            setRectangle(
                    gl, randomRange(-1.0, 1.0), randomRange(-1.0, 1.0), randomRange(-1.0, 1.0), randomRange(-1.0, 1.0));

            // Set a random color.
            gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);

            // Draw the rectangle.
            gl.drawArrays(gl.TRIANGLES, 0, 6);
          }
        }, 1000/fps);


      }
    }

    // Returns a random integer from 0 to range - 1.
    function randomRange(max, min) {
      var range = max - min;

      return min + Math.random()*range;
    }

    // Fill the buffer with the values that define a rectangle.
    function setRectangle(gl, x, y, width, height) {
      var x1 = x;
      var x2 = x + width;
      var y1 = y;
      var y2 = y + height;
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        x1, y1,
        x2, y1,
        x1, y2,
        x1, y2,
        x2, y1,
        x2, y2]), gl.STATIC_DRAW);
    }


  </script>
  <!-- vertex shader -->
  <script id="2d-vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0, 1);
  }
  </script>
  <!-- fragment shader -->
<script id="2d-fragment-shader" type="x-shader/x-fragment">
   precision mediump float;

   uniform vec4 u_color;

   void main() {
     gl_FragColor = u_color;
   }
</script>

{% endblock %}

{% block bodyblock %}
    <div class="container" role="main">
        <div class="container bob">
            <div class="jumbotron" id="portfoliotop">
                <h1>WebGL Projects</h1>
                <p class="lead">I have been experimenting with webGL in an
                    attempt to build a webGL GPU-based N-body simulation you can play with in your browser.
                    For now, check out this super awesome array of ever-changing rectangles:
                </p>
            </div>
        </div>
    </div>

    <div style="text-align:center; width:100%">
        <canvas id="canvas"></canvas>
    </div>
{% endblock %}